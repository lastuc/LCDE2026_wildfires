
R version 4.2.2 (2022-10-31) -- "Innocent and Trusting"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> #-----------------------------------------------------------------------------#
> #                          4. Extract daily exposures                         #
> #-----------------------------------------------------------------------------#
> 
> # packages
> library(here) # (1.0.1)
here() starts at /PROJECTES/AIRPOLLUTION/lara/LCDE2026_wildfires
> library(tidyverse) # (2.0.0)
── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.0     ✔ readr     2.1.4
✔ forcats   1.0.0     ✔ stringr   1.5.0
✔ ggplot2   3.4.1     ✔ tibble    3.2.0
✔ lubridate 1.9.2     ✔ tidyr     1.3.0
✔ purrr     1.0.1     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
> # library(data.table) # (1.17.0)
> library(terra) # (1.8-29)
terra 1.7.18

Attaching package: ‘terra’

The following object is masked from ‘package:tidyr’:

    extract

> # library(sf) # (1.0-19)
> # library(ISOweek) # (0.6-2)
> 
> pathroot <- "/PROJECTES/AIRPOLLUTION/lara/LCDE2026_wildfires/"
> # pathroot <- ""
> 
> pointnuts <- vect(paste0(pathroot, "data/processed/expocentroids_nuts.gpkg"))
> dfnuts <- as.data.frame(pointnuts)
> dayseq <- seq.Date(as.Date("2003-01-01"), as.Date("2024-12-31"), by = "1 day")
> # weekseq <- seq.Date(as.Date("2003-01-01"), as.Date("2024-12-31"), by = "1 week")
> population <- rast(paste0(pathroot, "data/processed/population_yearly.tif"))
> population <- subset(population, names(population) != "year")
> names(population) <- as.character(c(2003:2024))
> 
> # Extract geographical IDs, population, SILAM for each day-cell per year
> for(y in 2003:2024){
+ 
+   print(y)
+ 
+   # Extract population ----
+   ypop <- population[as.character(y)]
+   names(ypop) <- "population"
+   ypop <- terra::extract(ypop, pointnuts)[-1]
+ 
+   # Extract SILAM ----
+   yindex <- year(dayseq) == y
+   ysilam <- rast(paste0(pathroot, "data/raw/SILAM/europePMfire_2003to2024daymean.nc4"), lyrs = yindex)
+   names(ysilam) <- as.character(as.Date(time(ysilam)))
+   ysilam <- ysilam*1e+9 # change of units
+   ysilam <- terra::extract(ysilam, pointnuts)[-1]
+ 
+   # Merge, reformat ----
+   ydata <- cbind(dfnuts, ypop, ysilam)
+   ydata <- tidyr::pivot_longer(ydata,
+                                cols = -c("GRD_ID","NUTS_0","NUTS_2","NUTS_mort","region","population", "country", "eu"),
+                                names_to = "date", values_to = "pm25")
+   
+   # Calculate weekly average exposure and aggregate to weekly observations----
+   # Ensure the 'date' column is in Date format
+   ydata$date <- as.Date(ydata$date)
+   
+   # Add a column for the week (starting date of the week)
+   ydata <- ydata %>%
+     mutate(week_start = floor_date(date, unit = "week"))
+   
+   # Group by geographical ID and week_start, then calculate the mean
+   weekly_averages <- ydata %>%
+     group_by(GRD_ID, week_start) %>%
+     summarise(pm25_weekly_avg = mean(pm25, na.rm = T))
+   
+   # If needed, merge back with the original data
+   ydata_weekly <- inner_join(ydata, weekly_averages, by = c("GRD_ID", "date" = "week_start"))
+   
+   # Write ----
+   readr::write_csv(ydata_weekly, paste0(pathroot, "data/processed/assembled/data_weekly_", y,".csv"))
+   rm("ypop", "yindex", "ysilam", "ydata")
+ }
[1] 2003
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2004
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2005
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2006
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2007
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2008
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2009
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2010
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2011
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2012
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2013
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2014
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2015
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2016
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2017
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2018
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2019
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2020
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2021
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2022
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2023
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
[1] 2024
`summarise()` has grouped output by 'GRD_ID'. You can override using the
`.groups` argument.
> 
> rm(list = ls())
> 
> proc.time()
    user   system  elapsed 
1965.500  625.930 2825.687 
